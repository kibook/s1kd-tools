.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "s1kd-appcheck" "1" "2024-03-21" "" "s1kd-tools"
.hy
.SH NAME
.PP
s1kd-appcheck - Validate applicability of S1000D CSDB objects
.SH SYNOPSIS
.IP
.nf
\f[C]
s1kd-appcheck [options] [<object>...]
\f[R]
.fi
.SH DESCRIPTION
.PP
The \f[I]s1kd-appcheck\f[R] tool validates the applicability of S1000D
CSDB objects, detecting potential errors that could occur when the
object is filtered.
.PP
By default, the tool validates an object against only the product
attribute and condition values which are explicitly used within the
object.
The products check (-t) and full check (-a) modes allow objects to be
checked for issues with implicit applicability, that is, product
attribute or condition values which are not explicitly used within an
object, but may still affect it.
.PP
The s1kd-instance and s1kd-validate tools are used by default to perform
the actual validation.
.SH OPTIONS
.TP
-A, --act <file>
Specify the ACT to read product attributes from, and to use to find the
CCT or PCT.
This will override the ACT reference within the individual objects being
validated.
.TP
-a, --all
Validate objects against all possible combinations of relevant product
attribute and condition values as defined in the ACT and CCT.
Relevant product attributes and conditions are those that are used by an
object with any value.
.TP
-b, --brexcheck
Validate objects with a BREX check (using the s1kd-brexcheck tool) in
addition to the schema check.
.TP
-C, --cct <file>
Specify the CCT to read conditions from.
This will override the CCT reference within the ACT.
.TP
-c, --custom
Perform a customized check.
The default standalone applicability check is disabled.
This can then be combined with the -s option, to only check that all
product attributes and conditions are defined in the ACT and CCT
respectively, and/or the -n option, to only check nested applicability
annotations.
If neither of these options are specified, no checks will be performed.
.TP
-D, --duplicate
Check for duplicate annotations.
.TP
-d, --dir <dir>
The directory to start searching for ACT/CCT/PCT data modules in.
By default, the current directory is used.
.TP
-e, --exec <cmd>
The commands used to validate objects.
Multiple commands can be used by specifying this option multiple times.
The objects will be passed to each command on stdin, and the exit status
of the command will be used to determine if the object is valid (with a
non-zero exit status indicating it is invalid).
This overrides the default commands (s1kd-validate, and s1kd-brexcheck
if -b is specified).
.TP
-F, --valid-filenames
Print the filenames of valid objects.
.TP
-f, --filenames
Print the filenames of invalid objects.
.TP
-h, -?, --help
Show help/usage message.
.TP
-K, --filter <cmd>
The command used to filter objects prior to validation.
The objects will be passed to the command on stdin, and the filters will
be supplied as arguments in the form of
\[dq]\f[C]-s <ident>:<type>=<value>\f[R]\[dq].
This overrides the default command (s1kd-instance).
.TP
-k, --args <args>
The arguments to the filter command when filtering objects prior to
validation.
.TP
-l, --list
Treat input as a list of CSDB objects to validate.
.TP
-N, --omit-issue
Assume that the issue/inwork numbers are omitted from object filenames
(they were created with the -N option).
.TP
-n, --nested
Check that all product attribute and condition values used in nested
applicability annotations are subsets of the values used in their
parents.
.TP
-o, --output-valid
Output valid CSDB objects to stdout.
.TP
-P, --pct <file>
Specify the PCT to read product instances from.
This will override the PCT reference in the ACT.
.TP
-p, --progress
Display a progress bar.
.TP
-q, --quiet
Quiet mode.
Error messages will not be printed.
.TP
-R, --redundant
Check for redundant annotations.
.TP
-r, --recursive
Search for the ACT/CCT/PCT recursively.
.TP
-s, --strict
Check whether product attributes and conditions used by an object are
declared in the ACT and CCT respectively.
.TP
-T, --summary
Print a summary of the check after it completes, including statistics on
the number of objects that passed/failed the check.
.TP
-t, --products
Validate objects against the defined product instances within the PCT.
.TP
-v, --verbose
Verbose output.
Specify multiple times to increase the verbosity.
.TP
-x, --xml
Print an XML report of the check.
.TP
-\[ti], --dependencies
Check with CCT dependency tests added to assertions which use the
dependant values.
.TP
-\[ha], --remove-deleted
Validate objects with elements that have a change type of
\[dq]delete\[dq] removed.
.TP
--version
Show version information.
.TP
--zenity-progress
Print progress information in the zenity --progress format.
.TP
<object>...
Object(s) to validate.
.PP
In addition, the following options allow configuration of the XML
parser:
.TP
--dtdload
Load the external DTD.
.TP
--huge
Remove any internal arbitrary parser limits.
.TP
--net
Allow network access to load external DTD and entities.
.TP
--noent
Resolve entities.
.TP
--parser-errors
Emit errors from parser.
.TP
--parser-warnings
Emit warnings from parser.
.TP
--xinclude
Do XInclude processing.
.TP
--xml-catalog <file>
Use an XML catalog when resolving entities.
Multiple catalogs may be loaded by specifying this option multiple
times.
.SH EXIT STATUS
.TP
0
The check completed successfully, and all CSDB objects were valid.
.TP
1
The check completed successfully, but some CSDB objects were invalid.
.TP
2
One or more CSDB objects could not be read.
.TP
3
The number of CSDB objects specified exceeded the available memory.
.SH EXAMPLES
.SS Standalone validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>Version: A or Version: B</simplePara>
</displayText>
<evaluate andOr=\[dq]or\[dq]>
<assert
applicPropertyIdent=\[dq]version\[dq]
applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]A\[dq]/>
<assert
applicPropertyIdent=\[dq]version\[dq]
applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]B\[dq]/>
</evaluate>
</applic>
\&...
<referencedApplicGroup>
<applic id=\[dq]app-VersionB\[dq]>
<assert applicPropertyIdent=\[dq]version\[dq] applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]B\[dq]/>
</applic>
</referencedApplicGroup>
\&...
<levelledPara id=\[dq]par-0001\[dq] applicRefId=\[dq]app-VersionB\[dq]>
<title>Features of version B</title>
<para>...</para>
</levelledPara>
\&...
<levelledPara>
<title>More information</title>
<para>...</para>
<para>Refer to <internalRef internalRefId=\[dq]par-0001\[dq]/>.</para>
</levelledPara>
\&...
</dmodule>
\f[R]
.fi
.PP
There are two versions of the product, A and B, and the data module is
meant to apply to both.
.PP
By itself, the data module is valid:
.IP
.nf
\f[C]
$ s1kd-validate -v <DM>
s1kd-validate: SUCCESS: <DM> validates against schema <url>
\f[R]
.fi
.PP
Checking it with this tool, however, reveals an issue:
.IP
.nf
\f[C]
$ s1kd-appcheck <DM>
s1kd-appcheck: ERROR: <DM> is invalid when:
s1kd-appcheck: ERROR:   prodattr version = A
\f[R]
.fi
.PP
When the data module is filtered for version A, the first levelled
paragraph will be removed, which causes the reference to it in the
second levelled paragraph to become broken.
.SS Full validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>All</simplePara>
</displayText>
</applic>
\&...
<referencedApplicGroup>
<applic id=\[dq]app-IcyOrHot\[dq]>
<evaluate andOr=\[dq]or\[dq]>
<assert
applicPropertyIdent=\[dq]weather\[dq]
applicPropertyType=\[dq]condition\[dq]
applicPropertyValues=\[dq]Icy\[dq]/>
<assert
applicPropertyIdent=\[dq]weather\[dq]
applicPropertyType=\[dq]condition\[dq]
applicPropertyValues=\[dq]Hot\[dq]/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep>
<para>Locate the handle.</para>
</proceduralStep>
<proceduralStep id=\[dq]stp-0001\[dq] applicRefId=\[dq]app-IcyOrHot\[dq]>
<para>Put on gloves prior to touching the handle.</para>
</proceduralStep>
<proceduralStep>
<para>Grab the handle and turn it clockwise.</para>
</proceduralStep>
\&...
<proceduralStep>
<para>Remove the gloves you put on in <internalRef internalRefId=\[dq]stp-0001\[dq]/>.</para>
</proceduralStep>
\&...
</dmodule>
\f[R]
.fi
.PP
Once again, this data module is valid by itself:
.IP
.nf
\f[C]
$ s1kd-validate -v <DM>
s1kd-validate: SUCCESS: <DM> validates against schema <url>
\f[R]
.fi
.PP
This time, however, it also initially appears valid when this tool is
used:
.IP
.nf
\f[C]
$ s1kd-appcheck -v <DM>
s1kd-appcheck: SUCCESS: <DM> passed the applicability check.
\f[R]
.fi
.PP
However, now consider this snippet from the CCT:
.IP
.nf
\f[C]
<condCrossRefTable>
\&...
<condType id=\[dq]weatherType\[dq]>
<name>Weather type</name>
<descr>Possible types of weather conditions.</descr>
<enumeration applicPropertyValues=\[dq]Normal\[dq]/>
<enumeration applicPropertyValues=\[dq]Icy\[dq]/>
<enumeration applicPropertyValues=\[dq]Hot\[dq]/>
</condType>
\&...
<cond id=\[dq]weather\[dq] condTypeRefId=\[dq]weatherType\[dq]>
<name>Weather</name>
<descr>The current weather conditions.</descr>
</cond>
\&...
</condCrossRefTable>
\f[R]
.fi
.PP
There is a third value for the \f[C]weather\f[R] condition which is not
explicitly used within the data module, and therefore will not be
validated against in the default standalone check.
When \f[C]weather\f[R] has a value of \f[C]Normal\f[R], the
cross-reference in the last step in the example above becomes broken.
.PP
To catch errors with implicit applicability, the full check (-a) can be
used instead, which reads the values to check not from the data module
itself, but from the ACT and CCT referenced by the data module:
.IP
.nf
\f[C]
$ s1kd-appcheck -a <DM>
s1kd-appcheck: ERROR: <DM> is invalid when:
s1kd-appcheck: ERROR:   condition weather = Normal
\f[R]
.fi
.PP
This can also be fixed by making the applicability of the data module
explicit:
.IP
.nf
\f[C]
<applic>
<displayText>
<simplePara>Weather: Normal or Weather: Icy or
Weather: Hot</simplePara>
</displayText>
<evaluate andOr=\[dq]or\[dq]>
<assert
applicPropertyIdent=\[dq]weather\[dq]
applicPropertyType=\[dq]condition\[dq]
applicPropertyValues=\[dq]Normal\[dq]/>
<assert
applicPropertyIdent=\[dq]weather\[dq]
applicPropertyType=\[dq]condition\[dq]
applicPropertyValues=\[dq]Icy\[dq]/>
<assert
applicPropertyIdent=\[dq]weather\[dq]
applicPropertyType=\[dq]condition\[dq]
applicPropertyValues=\[dq]Hot\[dq]/>
</evaluate>
</applic>
\f[R]
.fi
.PP
In which case, the standalone check will now also detect the error:
.IP
.nf
\f[C]
$ s1kd-appcheck <DM>
s1kd-appcheck: ERROR: <DM> is invalid when:
s1kd-appcheck: ERROR:   condition weather = Normal
\f[R]
.fi
.SS Nested applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>Version: A, B</simplePara>
</displayText>
<assert
applicPropertyIdent=\[dq]version\[dq]
applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]A\[dq]/>
<assert
applicPropertyIdent=\[dq]version\[dq]
applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]B\[dq]/>
</applic>
\&...
<referencedApplicGroup>
<applic id=\[dq]app-C\[dq]>
<displayText>
<simplePara>Version: C</simplePara>
</displayText>
<assert
applicPropertyIdent=\[dq]version\[dq]
applicPropertyType=\[dq]prodattr\[dq]
applicPropertyValues=\[dq]C\[dq]/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep>
<para>Step A</para>
</proceduralStep>
<proceduralStep applicRefId=\[dq]app-C\[dq]>
<para>Step B</para>
</proceduralStep>
<proceduralStep>
<para>Step C</para>
</proceduralStep>
\&...
</dmodule>
\f[R]
.fi
.PP
Here, the whole data module is applicable to versions A and B, but an
individual step has been made applicable to version C.
Normally, this is not reported as an error, since the removal of this
step would not cause the data module to become invalid:
.IP
.nf
\f[C]
$ s1kd-appcheck -v <DM>
s1kd-appcheck: SUCCESS: <DM> passed the applicability check
\f[R]
.fi
.PP
However, the content is essentially useless, since it will never appear.
The -n option will report when the applicability of an element is
incompatible with the applicability of any parent elements or the whole
object:
.IP
.nf
\f[C]
$ s1kd-appcheck -n <DM>
s1kd-appcheck: ERROR: <DM>: proceduralStep on line 62 is applicable
when prodattr version = C, which is not a subset of the applicability
of the whole object.
\f[R]
.fi
.SS Redundant applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<proceduralStep applicRefId=\[dq]app-A\[dq]>
<para>Step A</para>
<figure applicRefId=\[dq]app-A\[dq]>
\&...
</figure>
</proceduralStep>
\f[R]
.fi
.PP
This is technically correct, but the annotation on the figure can be
considered redundant, since it has the same applicability as its
ancestor, and the applicability of an element is already inherited by
all its descendants automatically.
.PP
The -R (--redundant) option will report when the applicability of a
nested element is redundant:
.IP
.nf
\f[C]
$ s1kd-appcheck -R <DM>
s1kd-appcheck: ERROR: <DM>: figure on line 85 has the same
applicability as its parent proceduralStep on line 83 (app-A)
\f[R]
.fi
.PP
Currently, this check only detects when the exact same annotation (with
the same ID) is nested within itself.
In the future, this should also detect redundant logic between different
nested annotations.
.SS Duplicate applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic id=\[dq]app-0001\[dq]>
<assert applicPropertyIdent=\[dq]version\[dq] applicPropertyType=\[dq]prodattr\[dq] applicPropertyValues=\[dq]A\[dq]/>
</applic>
<applic id=\[dq]app-0002\[dq]>
<assert applicPropertyIdent=\[dq]version\[dq] applicPropertyType=\[dq]prodattr\[dq] applicPropertyValues=\[dq]A\[dq]/>
</referencedApplicGroup>
\f[R]
.fi
.PP
These annotations have duplicate logic, meaning only one is necessary.
The -D (--duplicate) option will report when an applicability annotation
is a duplicate of another annotation:
.IP
.nf
\f[C]
$ s1kd-appcheck -D <DM>
s1kd-appcheck: ERROR: <DM>: Annotation on line 47 is a duplicate of annotation on line 24.
\f[R]
.fi
.SH AUTHORS
khzae.net.
