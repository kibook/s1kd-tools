.\" Automatically generated by Pandoc 2.3.1
.\"
.TH "s1kd\-appcheck" "1" "2019\-07\-18" "" "s1kd\-tools"
.hy
.SH NAME
.PP
s1kd\-appcheck \- Validate applicability of S1000D CSDB objects
.SH SYNOPSIS
.IP
.nf
\f[C]
s1kd\-appcheck\ [options]\ [<object>...]
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[I]s1kd\-appcheck\f[] tool validates the applicability of S1000D
CSDB objects, detecting potential errors that could occur when the
object is filtered.
.PP
By default, the tool validates an object against only the product
attribute and condition values which are explicitly used within the
object.
The products check (\-t) and full check (\-a) modes allow objects to be
checked for issues with implicit applicability, that is, product
attribute or condition values which are not explicitly used within an
object, but may still affect it.
.PP
The s1kd\-instance and s1kd\-validate tools are used by default to
perform the actual validation.
.SH OPTIONS
.TP
.B \-A, \-\-act <file>
Specify the ACT to read product attributes from, and to use to find the
CCT or PCT.
This will override the ACT reference within the individual objects being
validated.
.RS
.RE
.TP
.B \-a, \-\-all
Validate objects against all possible combinations of relevant product
attribute and condition values as defined in the ACT and CCT.
Relevant product attributes and conditions are those that are used by an
object with any value.
.RS
.RE
.TP
.B \-b, \-\-brexcheck
Validate objects with a BREX check (using the s1kd\-brexcheck tool) in
addition to the schema check.
.RS
.RE
.TP
.B \-C, \-\-cct <file>
Specify the CCT to read conditions from.
This will override the CCT reference within the ACT.
.RS
.RE
.TP
.B \-c, \-\-basic
Only check that all product attributes and conditions are defined in the
ACT and CCT respectively, without performing any other validation.
.RS
.RE
.TP
.B \-d, \-\-dir <dir>
The directory to start searching for ACT/CCT/PCT data modules in.
By default, the current directory is used.
.RS
.RE
.TP
.B \-e, \-\-exec <cmd>
The commands used to validate objects.
Multiple commands can be used by specifying this option multiple times.
The objects will be passed to each command on stdin, and the exit status
of the command will be used to determine if the object is valid (with a
non\-zero exit status indicating it is invalid).
This overrides the default commands (s1kd\-validate, and s1kd\-brexcheck
if \-b is specified).
.RS
.RE
.TP
.B \-f, \-\-filenames
Print the filenames of invalid objects.
.RS
.RE
.TP
.B \-h, \-?, \-\-help
Show help/usage message.
.RS
.RE
.TP
.B \-k, \-\-args <args>
The arguments to the s1kd\-instance tool when filtering objects prior to
validation.
.RS
.RE
.TP
.B \-l, \-\-list
Treat input as a list of CSDB objects to validate.
.RS
.RE
.TP
.B \-N, \-\-omit\-issue
Assume that the issue/inwork numbers are omitted from object filenames
(they were created with the \-N option).
.RS
.RE
.TP
.B \-o, \-\-output\-valid
Output valid CSDB objects to stdout.
.RS
.RE
.TP
.B \-P, \-\-pct <file>
Specify the PCT to read product instances from.
This will override the PCT reference in the ACT.
.RS
.RE
.TP
.B \-p, \-\-progress
Display a progress bar.
.RS
.RE
.TP
.B \-q, \-\-quiet
Quiet mode.
Error messages will not be printed.
.RS
.RE
.TP
.B \-r, \-\-recursive
Search for the ACT/CCT/PCT recursively.
.RS
.RE
.TP
.B \-s, \-\-strict
Check whether product attributes and conditions used by an object are
declared in the ACT and CCT respectively.
.RS
.RE
.TP
.B \-T, \-\-summary
Print a summary of the check after it completes, including statistics on
the number of objects that passed/failed the check.
.RS
.RE
.TP
.B \-t, \-\-products
Validate objects against the defined product instances within the PCT.
.RS
.RE
.TP
.B \-v, \-\-verbose
Verbose output.
Specify multiple times to increase the verbosity.
.RS
.RE
.TP
.B \-x, \-\-xml
Print an XML report of the check.
.RS
.RE
.TP
.B \-~, \-\-dependencies
Check with CCT dependency tests added to assertions which use the
dependant values.
.RS
.RE
.TP
.B \-\-version
Show version information.
.RS
.RE
.TP
.B <object>...
Object(s) to validate.
.RS
.RE
.PP
In addition, the following options enable features of the XML parser
that are disabled as a precaution by default:
.TP
.B \-\-dtdload
Load the external DTD.
.RS
.RE
.TP
.B \-\-net
Allow network access to load external DTD and entities.
.RS
.RE
.TP
.B \-\-noent
Resolve entities.
.RS
.RE
.TP
.B \-\-xinclude
Do XInclude processing.
.RS
.RE
.SH EXIT STATUS
.TP
.B 0
The check completed successfully, and all CSDB objects were valid.
.RS
.RE
.TP
.B 1
The check completed successfully, but some CSDB objects were invalid.
.RS
.RE
.TP
.B 2
One or more CSDB objects could not be read.
.RS
.RE
.TP
.B 3
The number of CSDB objects specified exceeded the available memory.
.RS
.RE
.SH EXAMPLES
.SS Standalone validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>Version:\ A\ or\ Version:\ B</simplePara>
</displayText>
<evaluate\ andOr="or">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</evaluate>
</applic>
\&...
<referencedApplicGroup>
<applic\ id="app\-VersionB">
<assert\ applicPropertyIdent="version"\ applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
</referencedApplicGroup>
\&...
<levelledPara\ id="par\-0001"\ applicRefId="app\-VersionB">
<title>Features\ of\ version\ B</title>
<para>...</para>
</levelledPara>
\&...
<levelledPara>
<title>More\ information</title>
<para>...</para>
<para>Refer\ to\ <internalRef\ internalRefId="par\-0001"/>.</para>
</levelledPara>
\&...
</dmodule>
\f[]
.fi
.PP
There are two versions of the product, A and B, and the data module is
meant to apply to both.
.PP
By itself, the data module is valid:
.IP
.nf
\f[C]
$\ s1kd\-validate\ \-v\ <DM>
s1kd\-validate:\ SUCCESS:\ <DM>\ validates\ against\ schema\ <url>
\f[]
.fi
.PP
Checking it with this tool, however, reveals an issue:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ prodattr\ version\ =\ A
\f[]
.fi
.PP
When the data module is filtered for version A, the first levelled
paragraph will be removed, which causes the reference to it in the
second levelled paragraph to become broken.
.SS Full validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>All</simplePara>
</displayText>
</applic>
\&...
<referencedApplicGroup>
<applic\ id="app\-IcyOrHot">
<evaluate\ andOr="or">
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Icy"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Hot"/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep>
<para>Locate\ the\ handle.</para>
</proceduralStep>
<proceduralStep\ id="stp\-0001"\ applicRefId="app\-IcyOrHot">
<para>Put\ on\ gloves\ prior\ to\ touching\ the\ handle.</para>
</proceduralStep>
<proceduralStep>
<para>Grab\ the\ handle\ and\ turn\ it\ clockwise.</para>
</proceduralStep>
\&...
<proceduralStep>
<para>Remove\ the\ gloves\ you\ put\ on\ in\ <internalRef\ internalRefId="stp\-0001"/>.</para>
</proceduralStep>
\&...
</dmodule>
\f[]
.fi
.PP
Once again, this data module is valid by itself:
.IP
.nf
\f[C]
$\ s1kd\-validate\ \-v\ <DM>
s1kd\-validate:\ SUCCESS:\ <DM>\ validates\ against\ schema\ <url>
\f[]
.fi
.PP
This time, however, it also initially appears valid when this tool is
used:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-v\ <DM>
s1kd\-appcheck:\ SUCCESS:\ <DM>\ passed\ the\ applicability\ check.
\f[]
.fi
.PP
However, now consider this snippet from the CCT:
.IP
.nf
\f[C]
<condCrossRefTable>
\&...
<condType\ id="weatherType">
<name>Weather\ type</name>
<descr>Possible\ types\ of\ weather\ conditions.</descr>
<enumeration\ applicPropertyValues="Normal"/>
<enumeration\ applicPropertyValues="Icy"/>
<enumeration\ applicPropertyValues="Hot"/>
</condType>
\&...
<cond\ id="weather"\ condTypeRefId="weatherType">
<name>Weather</name>
<descr>The\ current\ weather\ conditions.</descr>
</cond>
\&...
</condCrossRefTable>
\f[]
.fi
.PP
There is a third value for the \f[C]weather\f[] condition which is not
explicitly used within the data module, and therefore will not be
validated against in the default standalone check.
When \f[C]weather\f[] has a value of \f[C]Normal\f[], the
cross\-reference in the last step in the example above becomes broken.
.PP
To catch errors with implicit applicability, the full check (\-a) can be
used instead, which reads the values to check not from the data module
itself, but from the ACT and CCT referenced by the data module:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-a\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ condition\ weather\ =\ Normal
\f[]
.fi
.PP
This can also be fixed by making the applicability of the data module
explicit:
.IP
.nf
\f[C]
<applic>
<displayText>
<simplePara>Weather:\ Normal\ or\ Weather:\ Icy\ or
Weather:\ Hot</simplePara>
</displayText>
<evaluate\ andOr="or">
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Normal"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Icy"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Hot"/>
</evaluate>
</applic>
\f[]
.fi
.PP
In which case, the standalone check will now also detect the error:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ condition\ weather\ =\ Normal
\f[]
.fi
.SH AUTHORS
khzae.net.
