.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "s1kd\-appcheck" "1" "2024\-08\-14" "" "s1kd\-tools"
.hy
.SH NAME
.PP
s1kd\-appcheck \- Validate applicability of S1000D CSDB objects
.SH SYNOPSIS
.IP
.nf
\f[C]
s1kd\-appcheck\ [options]\ [<object>...]
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[I]s1kd\-appcheck\f[] tool validates the applicability of S1000D
CSDB objects, detecting potential errors that could occur when the
object is filtered.
.PP
By default, the tool validates an object against only the product
attribute and condition values which are explicitly used within the
object.
The products check (\-t) and full check (\-a) modes allow objects to be
checked for issues with implicit applicability, that is, product
attribute or condition values which are not explicitly used within an
object, but may still affect it.
.PP
The s1kd\-instance and s1kd\-validate tools are used by default to
perform the actual validation.
.SH OPTIONS
.TP
.B \-A, \-\-act <file>
Specify the ACT to read product attributes from, and to use to find the
CCT or PCT.
This will override the ACT reference within the individual objects being
validated.
.RS
.RE
.TP
.B \-a, \-\-all
Validate objects against all possible combinations of relevant product
attribute and condition values as defined in the ACT and CCT.
Relevant product attributes and conditions are those that are used by an
object with any value.
.RS
.RE
.TP
.B \-b, \-\-brexcheck
Validate objects with a BREX check (using the s1kd\-brexcheck tool) in
addition to the schema check.
.RS
.RE
.TP
.B \-C, \-\-cct <file>
Specify the CCT to read conditions from.
This will override the CCT reference within the ACT.
.RS
.RE
.TP
.B \-c, \-\-custom
Perform a customized check.
The default standalone applicability check is disabled.
This can then be combined with the \-s option, to only check that all
product attributes and conditions are defined in the ACT and CCT
respectively, and/or the \-n option, to only check nested applicability
annotations.
If neither of these options are specified, no checks will be performed.
.RS
.RE
.TP
.B \-D, \-\-duplicate
Check for duplicate annotations.
.RS
.RE
.TP
.B \-d, \-\-dir <dir>
The directory to start searching for ACT/CCT/PCT data modules in.
By default, the current directory is used.
.RS
.RE
.TP
.B \-e, \-\-exec <cmd>
The commands used to validate objects.
Multiple commands can be used by specifying this option multiple times.
The objects will be passed to each command on stdin, and the exit status
of the command will be used to determine if the object is valid (with a
non\-zero exit status indicating it is invalid).
This overrides the default commands (s1kd\-validate, and s1kd\-brexcheck
if \-b is specified).
.RS
.RE
.TP
.B \-F, \-\-valid\-filenames
Print the filenames of valid objects.
.RS
.RE
.TP
.B \-f, \-\-filenames
Print the filenames of invalid objects.
.RS
.RE
.TP
.B \-h, \-?, \-\-help
Show help/usage message.
.RS
.RE
.TP
.B \-i, \-\-ignore <id:type>
Ignore a specified applicability property when validating.
.RS
.RE
.TP
.B \-K, \-\-filter <cmd>
The command used to filter objects prior to validation.
The objects will be passed to the command on stdin, and the filters will
be supplied as arguments in the form of
"\f[C]\-s\ <ident>:<type>=<value>\f[]".
This overrides the default command (s1kd\-instance).
.RS
.RE
.TP
.B \-k, \-\-args <args>
The arguments to the filter command when filtering objects prior to
validation.
.RS
.RE
.TP
.B \-l, \-\-list
Treat input as a list of CSDB objects to validate.
.RS
.RE
.TP
.B \-N, \-\-omit\-issue
Assume that the issue/inwork numbers are omitted from object filenames
(they were created with the \-N option).
.RS
.RE
.TP
.B \-n, \-\-nested
Check that all product attribute and condition values used in nested
applicability annotations are subsets of the values used in their
parents.
.RS
.RE
.TP
.B \-o, \-\-output\-valid
Output valid CSDB objects to stdout.
.RS
.RE
.TP
.B \-P, \-\-pct <file>
Specify the PCT to read product instances from.
This will override the PCT reference in the ACT.
.RS
.RE
.TP
.B \-p, \-\-progress
Display a progress bar.
.RS
.RE
.TP
.B \-q, \-\-quiet
Quiet mode.
Error messages will not be printed.
.RS
.RE
.TP
.B \-R, \-\-redundant
Check for redundant annotations.
.RS
.RE
.TP
.B \-r, \-\-recursive
Search for the ACT/CCT/PCT recursively.
.RS
.RE
.TP
.B \-s, \-\-strict
Check whether product attributes and conditions used by an object are
declared in the ACT and CCT respectively.
.RS
.RE
.TP
.B \-T, \-\-summary
Print a summary of the check after it completes, including statistics on
the number of objects that passed/failed the check.
.RS
.RE
.TP
.B \-t, \-\-products
Validate objects against the defined product instances within the PCT.
.RS
.RE
.TP
.B \-u, \-\-unstrict\-nested
Perform a nested applicability check (refer to the \-n, \-\-nested
option above) in "unstrict" mode.
The normal, strict nested check always checks that each individual
assert is a subset of its parent applicability, but in this mode errors
will only be reported if the applicability annotation as a whole is not
a subset of its parent.
.RS
.RE
.TP
.B \-v, \-\-verbose
Verbose output.
Specify multiple times to increase the verbosity.
.RS
.RE
.TP
.B \-x, \-\-xml
Print an XML report of the check.
.RS
.RE
.TP
.B \-~, \-\-dependencies
Check with CCT dependency tests added to assertions which use the
dependant values.
.RS
.RE
.TP
.B \-#, \-\-threads <x[,y]>
Specifies the number of parallel threads to use for object validation.
\f[C]x\f[] represents the number of threads used to iterate over the
list of objects.
\f[C]y\f[] represents the number of threads used to check each
individual object.
If both are specified, this means that in total \f[C]x\ *\ y\f[] threads
will be created.
When either is unspecified, the default value is 1.
.RS
.PP
The numbers chosen typically will depend on the number of CPU cores
available, how many objects are being validated, and the complexity of
the applicability in the objects.
Generally, the total number of threads (\f[C]x\ *\ y\f[]) should not
exceed the number of available cores.
If you are validating a large number of objects with relatively little
applicability, then \f[C]x\f[] should be greater than \f[C]y\f[].
On the other hand, if you are validating a small number of objects with
complex applicability, then \f[C]y\f[] should be greater than
\f[C]x\f[].
When validating a single object, \f[C]x\f[] should always be 1.
.PP
Benchmarks should be performed to find the combination that is the best
for your hardware and data.
.RE
.TP
.B \-^, \-\-remove\-deleted
Validate objects with elements that have a change type of "delete"
removed.
.RS
.RE
.TP
.B \-\-version
Show version information.
.RS
.RE
.TP
.B \-\-zenity\-progress
Print progress information in the zenity \-\-progress format.
.RS
.RE
.TP
.B <object>...
Object(s) to validate.
.RS
.RE
.PP
In addition, the following options allow configuration of the XML
parser:
.TP
.B \-\-dtdload
Load the external DTD.
.RS
.RE
.TP
.B \-\-huge
Remove any internal arbitrary parser limits.
.RS
.RE
.TP
.B \-\-net
Allow network access to load external DTD and entities.
.RS
.RE
.TP
.B \-\-noent
Resolve entities.
.RS
.RE
.TP
.B \-\-parser\-errors
Emit errors from parser.
.RS
.RE
.TP
.B \-\-parser\-warnings
Emit warnings from parser.
.RS
.RE
.TP
.B \-\-xinclude
Do XInclude processing.
.RS
.RE
.TP
.B \-\-xml\-catalog <file>
Use an XML catalog when resolving entities.
Multiple catalogs may be loaded by specifying this option multiple
times.
.RS
.RE
.SH EXIT STATUS
.TP
.B 0
The check completed successfully, and all CSDB objects were valid.
.RS
.RE
.TP
.B 1
The check completed successfully, but some CSDB objects were invalid.
.RS
.RE
.TP
.B 2
One or more CSDB objects could not be read.
.RS
.RE
.TP
.B 3
The number of CSDB objects specified exceeded the available memory.
.RS
.RE
.TP
.B 4
The commands used to filter and/or validate objects failed to be
executed.
.RS
.RE
.SH EXAMPLES
.SS Standalone validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>Version:\ A\ or\ Version:\ B</simplePara>
</displayText>
<evaluate\ andOr="or">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</evaluate>
</applic>
\&...
<referencedApplicGroup>
<applic\ id="app\-VersionB">
<assert\ applicPropertyIdent="version"\ applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
</referencedApplicGroup>
\&...
<levelledPara\ id="par\-0001"\ applicRefId="app\-VersionB">
<title>Features\ of\ version\ B</title>
<para>...</para>
</levelledPara>
\&...
<levelledPara>
<title>More\ information</title>
<para>...</para>
<para>Refer\ to\ <internalRef\ internalRefId="par\-0001"/>.</para>
</levelledPara>
\&...
</dmodule>
\f[]
.fi
.PP
There are two versions of the product, A and B, and the data module is
meant to apply to both.
.PP
By itself, the data module is valid:
.IP
.nf
\f[C]
$\ s1kd\-validate\ \-v\ <DM>
s1kd\-validate:\ SUCCESS:\ <DM>\ validates\ against\ schema\ <url>
\f[]
.fi
.PP
Checking it with this tool, however, reveals an issue:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ prodattr\ version\ =\ A
\f[]
.fi
.PP
When the data module is filtered for version A, the first levelled
paragraph will be removed, which causes the reference to it in the
second levelled paragraph to become broken.
.SS Full validation
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>All</simplePara>
</displayText>
</applic>
\&...
<referencedApplicGroup>
<applic\ id="app\-IcyOrHot">
<evaluate\ andOr="or">
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Icy"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Hot"/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep>
<para>Locate\ the\ handle.</para>
</proceduralStep>
<proceduralStep\ id="stp\-0001"\ applicRefId="app\-IcyOrHot">
<para>Put\ on\ gloves\ prior\ to\ touching\ the\ handle.</para>
</proceduralStep>
<proceduralStep>
<para>Grab\ the\ handle\ and\ turn\ it\ clockwise.</para>
</proceduralStep>
\&...
<proceduralStep>
<para>Remove\ the\ gloves\ you\ put\ on\ in\ <internalRef\ internalRefId="stp\-0001"/>.</para>
</proceduralStep>
\&...
</dmodule>
\f[]
.fi
.PP
Once again, this data module is valid by itself:
.IP
.nf
\f[C]
$\ s1kd\-validate\ \-v\ <DM>
s1kd\-validate:\ SUCCESS:\ <DM>\ validates\ against\ schema\ <url>
\f[]
.fi
.PP
This time, however, it also initially appears valid when this tool is
used:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-v\ <DM>
s1kd\-appcheck:\ SUCCESS:\ <DM>\ passed\ the\ applicability\ check.
\f[]
.fi
.PP
However, now consider this snippet from the CCT:
.IP
.nf
\f[C]
<condCrossRefTable>
\&...
<condType\ id="weatherType">
<name>Weather\ type</name>
<descr>Possible\ types\ of\ weather\ conditions.</descr>
<enumeration\ applicPropertyValues="Normal"/>
<enumeration\ applicPropertyValues="Icy"/>
<enumeration\ applicPropertyValues="Hot"/>
</condType>
\&...
<cond\ id="weather"\ condTypeRefId="weatherType">
<name>Weather</name>
<descr>The\ current\ weather\ conditions.</descr>
</cond>
\&...
</condCrossRefTable>
\f[]
.fi
.PP
There is a third value for the \f[C]weather\f[] condition which is not
explicitly used within the data module, and therefore will not be
validated against in the default standalone check.
When \f[C]weather\f[] has a value of \f[C]Normal\f[], the
cross\-reference in the last step in the example above becomes broken.
.PP
To catch errors with implicit applicability, the full check (\-a) can be
used instead, which reads the values to check not from the data module
itself, but from the ACT and CCT referenced by the data module:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-a\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ condition\ weather\ =\ Normal
\f[]
.fi
.PP
This can also be fixed by making the applicability of the data module
explicit:
.IP
.nf
\f[C]
<applic>
<displayText>
<simplePara>Weather:\ Normal\ or\ Weather:\ Icy\ or
Weather:\ Hot</simplePara>
</displayText>
<evaluate\ andOr="or">
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Normal"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Icy"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="Hot"/>
</evaluate>
</applic>
\f[]
.fi
.PP
In which case, the standalone check will now also detect the error:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>\ is\ invalid\ when:
s1kd\-appcheck:\ ERROR:\ \ \ condition\ weather\ =\ Normal
\f[]
.fi
.SS Nested applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<dmodule>
\&...
<applic>
<displayText>
<simplePara>Version:\ A,\ B</simplePara>
</displayText>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
\&...
<referencedApplicGroup>
<applic\ id="app\-C">
<displayText>
<simplePara>Version:\ C</simplePara>
</displayText>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="C"/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep>
<para>Step\ A</para>
</proceduralStep>
<proceduralStep\ applicRefId="app\-C">
<para>Step\ B</para>
</proceduralStep>
<proceduralStep>
<para>Step\ C</para>
</proceduralStep>
\&...
</dmodule>
\f[]
.fi
.PP
Here, the whole data module is applicable to versions A and B, but an
individual step has been made applicable to version C.
Normally, this is not reported as an error, since the removal of this
step would not cause the data module to become invalid:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-v\ <DM>
s1kd\-appcheck:\ SUCCESS:\ <DM>\ passed\ the\ applicability\ check
\f[]
.fi
.PP
However, the content is essentially useless, since it will never appear.
The \-n option will report when the applicability of an element is
incompatible with the applicability of any parent elements or the whole
object:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-n\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>:\ proceduralStep\ on\ line\ 62\ is\ applicable
when\ prodattr\ version\ =\ C,\ which\ is\ not\ a\ subset\ of\ the\ applicability
of\ the\ whole\ object.
\f[]
.fi
.PP
The \-u (\-\-unstrict\-nested) option performs the nested check in
"unstrict" mode.
How this differs from the normal, strict nested check can be illustrated
as follows:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-A">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
</applic>
<applic\ id="app\-B">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
<applic\ id="app\-A\-or\-B">
<evaluate\ andOr="or">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
</referencedApplicGroup>
\&...
<proceduralStep\ applicRefId="app\-A">
<para>Step\ 1</para>
<proceduralStep\ applicRefId="app\-A\-or\-B">
<para>Step\ 1.1</para>
</proceduralStep>
<proceduralStep\ applicRefId="app\-B">
<para>Step\ 1.2</para>
</proceduralStep>
</proceduralStep>
\f[]
.fi
.PP
When performing a normal, strict nested check, both steps 1.1 and 1.2
will be reported as having nested applicability errors, because they are
inside a step that is applicable only to Version A yet each contain an
assertion for Version B.
However, in unstrict mode, only Step 1.2 will be reported as an error,
because the applicability of Step 1.1 is "A \f[I]or\f[] B" and so is
technically still valid (even though the inclusion of B can be
considered pointless).
.SS Redundant applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<proceduralStep\ applicRefId="app\-A">
<para>Step\ A</para>
<figure\ applicRefId="app\-A">
\&...
</figure>
</proceduralStep>
\f[]
.fi
.PP
This is technically correct, but the annotation on the figure can be
considered redundant, since it has the same applicability as its
ancestor, and the applicability of an element is already inherited by
all its descendants automatically.
.PP
The \-R (\-\-redundant) option will report when the applicability of a
nested element is redundant:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-R\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>:\ figure\ on\ line\ 85\ has\ the\ same
applicability\ as\ its\ parent\ proceduralStep\ on\ line\ 83\ (app\-A)
\f[]
.fi
.RS
.PP
\f[B]Note\f[]
.PP
Currently, this check only detects when the exact same annotation (with
the same ID) is nested within itself.
In the future, this should also detect redundant logic between different
nested annotations.
.RE
.SS Duplicate applicability annotations
.PP
Consider the following data module snippet:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-0001">
<assert\ applicPropertyIdent="version"\ applicPropertyType="prodattr"\ applicPropertyValues="A"/>
</applic>
<applic\ id="app\-0002">
<assert\ applicPropertyIdent="version"\ applicPropertyType="prodattr"\ applicPropertyValues="A"/>
</referencedApplicGroup>
\f[]
.fi
.PP
These annotations have duplicate logic, meaning only one is necessary.
The \-D (\-\-duplicate) option will report when an applicability
annotation is a duplicate of another annotation:
.IP
.nf
\f[C]
$\ s1kd\-appcheck\ \-D\ <DM>
s1kd\-appcheck:\ ERROR:\ <DM>:\ Annotation\ on\ line\ 47\ is\ a\ duplicate\ of\ annotation\ on\ line\ 24.
\f[]
.fi
.SH AUTHORS
khzae.net.
